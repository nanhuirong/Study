vmstat 监控CPU利用率
jstack -l 23474 > thread-dump dump线程信息
iostat 监控磁盘利用率

独占锁是一种悲观的技术,
CAS 比较并交换 包含3个操作, 需要读写的内存位置V, 进行比较的值A, 拟写入的新值B
              当且仅当V==A, B才会执行
              将会使使调用者处于竞争问题
              (类似于交通问题, 交通拥堵时, 信号灯有利于提高吞吐量, 不是特别拥堵时, 环岛能实现更高的吞吐量)

1. java并发编程包    java.util.concurrent

2.并发编程开销
    锁与检测
    环境切换的次数
    线程的个数
    调度
    内存的局部性
    算法设计


3.并发编程
    1).块并发编程
        synchronized    用在代码块或者方法上  临界区
            只能锁定对象, 不能锁定原始类型
            被锁定的对象数组的单个对象不会被锁定
            静态同步方法会所定他的Class对象
            内部类的同步独立于外部类


        volatile
            线程所见的值会在使用之前从主内存区域读出
            线程所写的值总会在指令完成前被flush到主内存


4.同步工具
    阻塞队列
    信号量
    栅栏  等待线程
    闭锁  等待事件
         Latch
         FutureTask


5.并发编程小结
    可变状态, 所有的并发编程完那提都可以归结wier如何协调对并发状态的访问, 可变状态越少, 越容易保证安全性
    尽量将域声明为final, 除非他们是可变的
    不可变对象绝对时线程安全的
    用锁来保护每一个可变变量


6.Executor框架    任务执行的抽象
    基于生产者消费者模式: 提交任务的操作相当于生产者, 执行任务的线程相当于消费者
    Executors.newFixedThreadPool()  创建一个固定长度的线程池 利用LinkedBlockingQueue 表示一个无界队列
              newCachedThreadPool() 创建一个可缓存的线程, 动态扩张和缩小, 线程池的规模不受任何限制
              newSingleThreadExecutor() 创建一个单线程的线程池利用LinkedBlockingQueue 表示一个无界队列
              newScheduledThreadPool()  创建一个固定长度的线程池, 而且以延时或者定时的方式执行

    关闭线程池   ExecutorService
        shutDown()  平滑结束线程池 不再接受新任务, 并等待已提交任务的完成
        shutdownNow()   尝试取消所有的运行中的任务, 并不再执行已经提交的任务并将其返回


    缺点:没有办法返回一个值, 抛出一个受检测的异常
         已提交但是未开始的任务可以取消, 已开始的任务只有当他们可以响应中断时才可以取消


7.Timer负责管理延时任务和周期任务(有缺陷)
    考虑用newScheduledThreadPool()来替代

    利用DelayQueue + SchedulerThreadPoolExecutor



8.Callable与Future(表示一个任务的生命周期)
    Runnable 与Callable描述的都是抽象的计算任务
    Callable    call函数可能返回一个值或者抛出一个异常
    Runnable

    Future  还可用于定时任务的管理,


9.线程取消和终止
    取消
        通常, 中断是实现取消最合理的方式
        通过Future来实现取消  Future.cancel()  true任务正在运行可以被取消
                                             false任务还没有启动, 就不用运行



10.线程池的使用
    任务依赖其他任务, 可能产生死锁(线程饥饿死锁)

    ThreadPoolExecutor 更灵活稳定的线程池

    队列饱和策略  线程池队列饱和
        AbortPolicy 默认的饱和测略, 会抛出异常
        CallerRunsPolicy
        DiscardPolicy   丢弃策略
        DiscardOldestPolicy 丢弃最老策略 将任务返回到调用者

    定制线程工厂
    定制ThreadPoolExecutor


11.线程安全性和活跃性之间存在一种平衡:
    通过加锁来保证线程安全, 但是过度使用锁会导致锁顺序死锁
    通过信号量和线程池限制对资源的使用, 但是这些限制的行为可能导致资源死锁

12.死锁(JVM无法解决死锁的问题)
   如果所有线程均已固定顺序获得锁, 那么在程序中将不会产生死锁问题
    1)哲学家进餐问题:(资源死锁)
    2)避免死锁:一个线程每次至多获得一个锁, 就不会产生死锁,
              如果必须获取多个锁, 在设计时必须考虑锁的顺序
              a)支持定时锁, 使用Lock类的tryLock功能取代内置锁(如果没有获得锁, 就会一直等待下去), 显示锁设置了一个超时机制

              b)通过线程转储信息(JVM Thread DUMP)来识别死锁的发生
                jstack -l 23474 > thread-dump



13.线程饥饿 避免使用线程有限级, 会增加平台依赖性

14.活锁  比如处理事务型操作时,
         解决方案: 在重试中引入随机机制
         perfbar 性能测试工具

15.Amdahl定律
    speedup <= 1/(F + (1-F)/ N)
    N 处理器个数
    F 必须被串行的部分


16.多线程引入的开销
    上下文切换 当线程数>CPU核数
    内存同步
    阻塞

17.锁分段和锁分解技术
    锁分段 锁上的竞争频率高于锁上数据发生竞争的频率


    热点域会限制可扩展性


18.代替独占锁
    使用并发容器
    读写锁 ReadWriteLock 多个读取单个写入下加锁的规则:并发读取并不会改变共享资源
    不可变对象
    原子变量 代替热点域


19.显式锁
    Lock
    ReentrantLock 实现了Lock接口, 并提供与synchronized相同的互斥性与内存可见性
                  支持轮询和定时操作
                  避免写写, 写读冲突

    ReadWriteLock 读写锁, 允许多个线程同时读, 但是只允许一个线程写
                  一个读锁, 一个写锁
    ReentrantLock提供了可重入语义, (公平锁)如果一个线程获取读锁, 有一个线程等待写入锁, 那么其他线程均不能获取读锁,
                 直到写线程释放写锁
                 (非公平锁)线程访问许可的顺序是不确定的, 写线程降级为读线程时可以的, 但是读线程升级为写线程是不可以的

20.JVM内存模型, JMM(java 内存模型)
    在共享内存的多处理器体系架构, 每个处理器都由自己的缓存, 并定期与主内存进行协调
    1)重排序
    2)偏序关系 Happens-Before, 如果两个操作之间缺乏偏序关系, JVM可以对他们进行任意重拍序
    3)借助同步(Piggyback),


21.类标注
    @Immutable  不可变, 包含@ThreadSafe
    @ThreadSafe
    @NotThreadSafe

22.域和方法的标注
    @GuardedBy(lock) 表示只有在持有特定特定的锁时才能访问该域


23.原子变量和非阻塞同步机制
    volatile 当一个变量依赖另一个变量或者当前变量的值依赖于旧值, 不适合
    原子变量:更好的volatile
            标量:AtomicInteger, AtomicLong, AtomicBoolean, AtomicRefence
    非阻塞算法:(通常不会出现死锁, 优先级反转等情况, 但是有可能出现饥饿或者活锁)
              非阻塞的栈

              ABA问题:加入版本号



24. Condition显示的Condition对象
25.AbstractQueuedSynchronizer 负责管理同步器中的状态









