1.内置锁的缺点:引起混乱, 迫使JVM需要在对象大小和加锁性能之间进行权衡
2.最低安全保证:线程可能得到一个失效的值, 但是这个值之前每个线程设者的, 并非一个随机值(HBase的最低安全保证)
              但是64位的数值不满足这个条件, JVM允许64位的读写分为两个32的操作
3.ThreadLocal与线程封闭, 将需要封闭的共享对象放入ThreadLcoal中
4.final域时无法修改的, 但是如果引用的是可变对象, 这些被引用的对象是可以修改的
5.不可变对象也是实现并发的一种优秀实现
6.多线程编程对象一般用final修饰
7.加锁必须保证加的是同一把锁, 否则加锁没有任何的意义