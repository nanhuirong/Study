http://wiki.jikexueyuan.com/project/java-nio-zh/java-nio-non-blocking-server.html
java nio 小型项目
https://github.com/jjenkov/java-nio-server




io  最老  面向流, 是阻塞的, 数据量不大或者不在意阻塞的时候可以选择使用
nio 1.4特性   (Non Block io), 同步非阻塞IO模型, IO多路复用的基础
              面向块, 先把数据搬运放入缓存, 同步非阻塞 nio有buffer作为缓冲区, Channel相当于io的Stream抽象，
              Selector相当于nio提供的多Channel工具
aio 1.7特性   加入异步特性, aio提供事件处理接口CompletionHandler, 并定义回调函数, 这些函数在io完成后自动被调用





1. 阻塞IO BIO(Block IO)
    面向字节流和字符流
    一个链接一个线程, 多线程采用线程池
    缺点: 线程创建和销毁成本比较高(linux中线程其实就是一个进程)
          线程本身占内存较大, 512K-1M之间, (如果线程数过千, JVM消耗较大)
          线程切换成本较大

2. NIO 非阻塞IO   (Non Block IO)
    面向通道和缓冲区
    系统IO分为两个阶段  等待就绪和操作
                    读:等待系统可读和真正的读
                    写:等待网卡可写和真正的写
    事件: 读就绪
          写就绪
          新联接到来


    核心组建:Channels(read data into Buffers, Buffers write data into Channel)
                FileChannel 文件读写    只能在阻塞模式下运行
                DatagramChannel UDP数据读写
                SocketChannel   TCP数据读写
                ServerSocketChannel 允许监听TCP链接请求, 每个请求创建一个SockerChannel
            Buffers(一块内存区域)
                ByteBuffer
                CharBuffer
                DoubleBuffer
                FloatBuffer
                IntBuffer
                LongBuffer
                ShortBuffer

                将数据写入Buffer
                调用flip() 需要读书据时将buffer从写模式调整为读模式
                从Buffer中读取数据
                调用Buffer.clear清空buffer数据 Buffer.compact 清空已读取数据

            属性
                Capacity    容量 Buffer的大小固定
                position    位置 写模式, 写入位置, 默认从0开始
                                 读模式
                limit   限制  写模式 == Capacity
                              读模式 读模式下所能读取的最大数据量

            Selectors(允许单线程操作多通道) 用于检查一个或多个niochannel是否处于可读 可写状态
                      允许单线程管理多个channel

                      FileChannel不适用于Selector,

    设计思想:单线程轮询事件, 找到可以进行读写的网络描述符进行读写(事件的轮询时阻塞的)
    模型实现:事件分发, 单线程选择就绪的事件
            IO处理器, 包括read connect write, 开启CPU核心数个线程就ok
            业务线程, 处理完IO后一般还会有业务逻辑

    Java的selector对于linxu系统的限制:同一个channel的select不能被并发的调用。
    因此，如果有多个I/O线程，必须保证：一个socket只能属于一个IoThread，而一个IoThread可以管理多个socket。

    Dedis
    Thrift
    Dubbo


    IO复用机制需要事件分发器
    涉及事件分发器的模型 Reactor Proactor
    Reactor 基于同步IO
    Proactor 基于异步IO

    成熟的NIO框架, Netty, MINA




3. AIO 异步IO