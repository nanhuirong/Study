1. ArrayList 与 LinkedList
    ArrayList:基于一个数组, 自动进行扩容
    LinkedList: 基于双向链表,
   ArrayList 读取效率高, 但是写入效率不高 适合随机读取
             并发实现CopyOnWriteArrayList
   LinkedList 读取效率不高, 写入效率可以, 适合顺序读取

   若需要并发控制, 采用Collections.synchroniedList()

   原理:写入时复制(copy-on-write), 迭代多余修改
   CopyOnWriteArrayList
   CopyOnWriteArraySet


2. Map用于保存<key, value>型的数据, Java四种常见的实现 HashMap HashTable TreeMap LinkedHashMap
    HashMap 根据key的hashCode存储数据, 最多允许1条记录的key为null, 多条记录的值为null
            非线程安全, 如果需要线程安全(使用Collections的synchronizedMap使HashMap具有线程安全的能力
            或者使用ConcurrentHashMap(读取时不用修改锁, 写入时只锁住要修改的桶))
            如果key是null, 直接从table[0]对应的链表开始查找
            设计原理:采用链表地址方式解决hash冲突, 在链表中引入红黑数
            重点内容:table 扩容机制(threshold 容纳的<key, value>对 = length * loadfactor), 扩容会变为原先的2倍.
                    hash 计算索引
                    put机制

           ConcurrentHashMap 采用分段锁机制(默认下, 整个桶被16个锁分别管理, 最多支持16个线程的并发访问)
                             为每一个分段提供一个计数器
           与HashTable 和synchronizedHashMap


            HashMap线程不安全: 多个线程添加元素 如果出现key碰撞, 则会添加到同一个位置,会发生数据的覆盖
                              发生resize的时候, 容易引起死循环

    HashTable(JDK1.5之后弃用) 线程安全, 效率不如ConcurrentHashMap

    LinkedHashMap 保存了记录的插入顺序, 在HashMap的基础上采用双向链表保证数据的插入顺序

    TreeMap 默认按照key升序排列,也可以构造排序器, 并发 Collections.synchronizedSortedMap()

    ------------------------------------------------------------------------------------------
    HashMap 与HashTable hash运算
        HashTable key.hashCode % table.length 效率低下
        HashMap h&(table.length - 1) 代替%运算, h是key.hashCode(其实内部有一个移位运算)

        HashTable 的线程安全实现比较古老其实就是加锁, 而且key和value均不能为空
                  key 如果是null, hashCode方法调用失败, HashMap做了一下异常处理


3. Set、List接口是Collection接口的子接口, 分别是Java的无序和有序集合, 这里指的是插入顺序
   Queue是Java的队列实现

   Set  HashSet 内部维护了一个HashMap, 内部只利用key, value没用所有的value指向同一个对象
        LinkedHashSet 内部维护了一个LinkedHashMap



4.Queue
    1)BlockingQueue
        LinkedBlockingQueue
        ArrayBlockingQueue

    2)TransferQueue

    3)ConcurrentLinkedQueue

    4)PriorityQueue 非并发的优先队列



---------------------------------------------------------------------------------------------
多线程下的容器
1.阻塞队列 可用于生产者-消费者模式
  BlockingQueue
    LinkedBlockQueue    先进先出的队列
    ArrayBlockingQueue

    PriorityQueue   基于优先级的队列

    SynchronousQueue    并不是一个真正的队列, 维护一组线程


2.双端队列
  Deque
    ArrayDeque
  BlockingDeque
    LinkedBlockingDeque


  适用于工作密取, 每个消费线程有自己的双端队列, 当自己队列为空时, 从别的线程的队列尾部取元素
  既是生产者问题又是消费者问题



